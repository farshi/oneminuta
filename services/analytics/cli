#!/usr/bin/env python3
"""
OneMinuta Telegram Analytics CLI
Main command-line interface for all analytics operations
"""

import sys
import os
import asyncio
import argparse
from pathlib import Path

# Add project root to path  
project_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(project_root))

from services.analytics.config import get_config
from services.analytics.session_manager import get_session_manager


def main():
    parser = argparse.ArgumentParser(
        prog='telegram-analytics',
        description='OneMinuta Telegram Analytics - Identify hot property clients'
    )
    
    subparsers = parser.add_subparsers(dest='command', help='Available commands')
    
    # Auth command
    auth_parser = subparsers.add_parser('auth', help='Authenticate with Telegram')
    auth_parser.add_argument('--phone', help='Phone number with country code')
    
    # Analyze command
    analyze_parser = subparsers.add_parser('analyze', help='Analyze Telegram channels')
    analyze_parser.add_argument('--days', type=int, default=3, help='Days to look back (default: 3)')
    analyze_parser.add_argument('--channels', nargs='+', help='Specific channels to analyze')
    
    # Test command
    test_parser = subparsers.add_parser('test', help='Run tests')
    test_parser.add_argument('type', choices=['access', 'filter', 'performance', 'all'], 
                            help='Type of test to run')
    
    # Monitor command
    monitor_parser = subparsers.add_parser('monitor', help='Start real-time monitoring')
    monitor_parser.add_argument('--duration', type=int, help='Duration in seconds (default: continuous)')
    
    # Debug command
    debug_parser = subparsers.add_parser('debug', help='Debug channel messages')
    debug_parser.add_argument('--channel', help='Specific channel to debug')
    debug_parser.add_argument('--limit', type=int, default=10, help='Number of messages to check')
    
    # List command
    list_parser = subparsers.add_parser('list', help='List hot clients')
    list_parser.add_argument('--min-score', type=float, default=60.0, help='Minimum hotness score')
    list_parser.add_argument('--limit', type=int, default=10, help='Maximum clients to show')
    
    # Clean command
    clean_parser = subparsers.add_parser('clean', help='Clean storage and sessions')
    clean_parser.add_argument('--keep-sessions', action='store_true', help='Keep session files')
    
    # Property Collection Commands
    collect_parser = subparsers.add_parser('collect', help='Collect properties from Telegram channels')
    collect_parser.add_argument('--days', type=int, default=7, help='Days to look back (default: 7)')
    collect_parser.add_argument('--channels', nargs='+', help='Specific channels to collect from')
    collect_parser.add_argument('--limit', type=int, default=100, help='Max messages per channel')
    collect_parser.add_argument('--dry-run', action='store_true', help='Show what would be collected without storing')
    
    properties_parser = subparsers.add_parser('properties', help='List collected properties')
    properties_parser.add_argument('--limit', type=int, default=20, help='Max properties to show')
    properties_parser.add_argument('--type', help='Filter by asset type (condo, house, land)')
    properties_parser.add_argument('--transaction', help='Filter by transaction (sale, rent)')
    properties_parser.add_argument('--agent', help='Filter by agent ID')
    properties_parser.add_argument('--min-price', type=float, help='Minimum price')
    properties_parser.add_argument('--max-price', type=float, help='Maximum price')
    
    stats_parser = subparsers.add_parser('stats', help='Show collection statistics')
    
    extract_test_parser = subparsers.add_parser('extract-test', help='Test property extraction on sample text')
    extract_test_parser.add_argument('text', help='Sample property listing text to test')
    
    geo_test_parser = subparsers.add_parser('geo-test', help='Test geo-spatial search')
    geo_test_parser.add_argument('lat', type=float, help='Center latitude')
    geo_test_parser.add_argument('lon', type=float, help='Center longitude')
    geo_test_parser.add_argument('radius', type=float, help='Search radius in meters')
    
    country_test_parser = subparsers.add_parser('country-test', help='Test country-wide asset search')
    country_test_parser.add_argument('--country', default='TH', help='Country code (default: TH)')
    
    args = parser.parse_args()
    
    if not args.command:
        parser.print_help()
        sys.exit(0)
    
    # Load environment
    from dotenv import load_dotenv
    load_dotenv()
    
    # Run appropriate command
    if args.command == 'auth':
        asyncio.run(run_auth(args))
    elif args.command == 'analyze':
        asyncio.run(run_analyze(args))
    elif args.command == 'test':
        asyncio.run(run_test(args))
    elif args.command == 'monitor':
        asyncio.run(run_monitor(args))
    elif args.command == 'debug':
        asyncio.run(run_debug(args))
    elif args.command == 'list':
        asyncio.run(run_list(args))
    elif args.command == 'clean':
        run_clean(args)
    elif args.command == 'collect':
        asyncio.run(run_collect(args))
    elif args.command == 'properties':
        asyncio.run(run_properties(args))
    elif args.command == 'stats':
        run_stats(args)
    elif args.command == 'extract-test':
        asyncio.run(run_extract_test(args))
    elif args.command == 'geo-test':
        asyncio.run(run_geo_test(args))
    elif args.command == 'country-test':
        asyncio.run(run_country_test(args))


async def run_auth(args):
    """Run authentication"""
    from services.analytics.session_manager import TelegramSessionManager
    
    api_id = int(os.getenv('TELEGRAM_API_ID', 0))
    api_hash = os.getenv('TELEGRAM_API_HASH', '')
    
    if not api_id or not api_hash:
        print("‚ùå Please set TELEGRAM_API_ID and TELEGRAM_API_HASH in .env")
        return
    
    manager = TelegramSessionManager(api_id, api_hash)
    success = await manager.authenticate_interactive(phone=args.phone)
    
    if success:
        print("‚úÖ Authentication successful!")
    else:
        print("‚ùå Authentication failed")
    
    await manager.disconnect()


async def run_analyze(args):
    """Run channel analysis"""
    from scripts.analyze_channels_only import analyze_channels_historical
    
    config = get_config()
    channels = args.channels or config.DEFAULT_CHANNELS
    print(f"üìä Analyzing {', '.join(channels)} for last {args.days} days...")
    
    await analyze_channels_historical(days_back=args.days)


async def run_test(args):
    """Run tests"""
    if args.type == 'access':
        from tests.test_channel_access import test_channels
        await test_channels()
    elif args.type == 'filter':
        from scripts.debug_channel_messages import debug_messages
        await debug_messages()
    elif args.type == 'performance':
        from tests.test_performance import test_performance
        await test_performance()
    elif args.type == 'all':
        print("üß™ Running all tests...")
        
        print("\n1Ô∏è‚É£ Testing channel access...")
        from tests.test_channel_access import test_channels
        await test_channels()
        
        print("\n2Ô∏è‚É£ Testing message filtering...")
        from scripts.debug_channel_messages import debug_messages
        await debug_messages()
        
        print("\n‚úÖ All tests completed!")


async def run_monitor(args):
    """Run real-time monitoring"""
    from tests.test_realtime_monitor import start_realtime_monitor
    
    if args.duration:
        print(f"üì° Starting monitor for {args.duration} seconds...")
        await asyncio.wait_for(start_realtime_monitor(), timeout=args.duration)
    else:
        print("üì° Starting continuous monitoring (Ctrl+C to stop)...")
        await start_realtime_monitor()


async def run_debug(args):
    """Debug channel messages"""
    from scripts.debug_channel_messages import debug_messages
    await debug_messages()


async def run_list(args):
    """List hot clients"""
    from services.analytics.cli import list_hot_clients
    from argparse import Namespace
    
    cli_args = Namespace(
        min_score=args.min_score,
        limit=args.limit,
        verbose=True
    )
    await list_hot_clients(cli_args)


def run_clean(args):
    """Clean storage and sessions"""
    import shutil
    
    print("üßπ Cleaning up...")
    
    # Clean analytics storage
    analytics_path = Path('./storage/analytics')
    if analytics_path.exists():
        shutil.rmtree(analytics_path)
        analytics_path.mkdir(parents=True)
        print("‚úÖ Cleaned analytics storage")
    
    # Clean sessions unless keeping
    if not args.keep_sessions:
        sessions_path = Path('./sessions')
        if sessions_path.exists():
            shutil.rmtree(sessions_path)
            sessions_path.mkdir()
            print("‚úÖ Cleaned session files")
    
    print("üßπ Cleanup complete!")


async def run_collect(args):
    """Run property collection"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    cli = PropertyCollectionCLI()
    await cli.collect_properties(
        channels=args.channels,
        days_back=args.days,
        limit=args.limit,
        dry_run=args.dry_run
    )


async def run_properties(args):
    """List collected properties"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    # Build filters
    filters = {}
    if args.type:
        filters['asset_type'] = args.type
    if args.transaction:
        filters['rent_or_sale'] = args.transaction
    if args.agent:
        filters['agent_id'] = args.agent
    if args.min_price:
        filters['min_price'] = args.min_price
    if args.max_price:
        filters['max_price'] = args.max_price
    
    cli = PropertyCollectionCLI()
    await cli.list_properties(limit=args.limit, filters=filters)


def run_stats(args):
    """Show collection statistics"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    cli = PropertyCollectionCLI()
    cli.show_stats()


async def run_extract_test(args):
    """Test property extraction"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    cli = PropertyCollectionCLI()
    await cli.test_extraction(args.text)


async def run_geo_test(args):
    """Test geo-spatial search"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    cli = PropertyCollectionCLI()
    await cli.test_geo_search(args.lat, args.lon, args.radius)


async def run_country_test(args):
    """Test country-wide search"""
    sys.path.insert(0, str(Path(__file__).parent.parent.parent))
    from services.collector.cli import PropertyCollectionCLI
    
    cli = PropertyCollectionCLI()
    await cli.test_country_search(args.country)


if __name__ == '__main__':
    main()